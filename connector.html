<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Constraint System Test</title>
  <script src='./lib/fabric.min.js'></script>
</head>

<body>

  <div id="bd-wrapper" ng-controller="CanvasControls">
    <h2>Connector Test</h2>

    <p>
      Connector line Test
    <p>
      <button id="anchor">toggle anchor</button>
      <button id="showHelper">toggle ui</button>
      <button id="shrink">shrink</button>
      <button id="expand">expand</button>
      <button id="load-circle">circle</button>
      <button id="load-bar1">bar1</button>
      <button id="load-bar2">bar2</button>
      <button id="load-bar3">bar3</button>
      <button id="load-nuron1">neuron1</button>
      <button id="load-nuron2">neuron2</button>
      <button id="load-nuron-head">neuron-head</button>
      <button id="load-nuron-stem">neuron-stem</button>
      <button id="load-nuron-tail">neuron-tail</button>
      <button id="load-chemistry">chemistry</button>
      <button id="load-cell">cell</button>
      <button id="load-last">load last</button>
      <input type="file" id="load-custom"></input>
    </p>

    <canvas id="c" width="1200" height="650" style="border:1px solid #ccc"></canvas>
    <script id="main">(function () {

        var canvas = this.__canvas = new fabric.Canvas('c');
        canvas.setWidth(window.width);
        canvas.setHeight(window.height);
        fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';
        fabric.Object.prototype.transparentCorners = false;
        fabric.Object.prototype.objectCaching = true;
        canvas.selection = false; // no group selection

        // positions, fixed, edge array
        let nPoints = 0;
        let nEdges = 0;
        let pos = [];
        let fixed = [];
        let anchored = [];
        let edges = [];

        let renderDots = [];
        let renderEdges = [];
        let renderImages = [];

        let toMergeIndex = -1;
        let showHelper = true;
        let lastFile = '';
        const pointRadius = 5;
        const maxIterations = 1000;
        const changeThreshold = 1; // accumulated distance error in pixel
        const equalEps = 0.0001;
        const maxImageDimension = 300; // pix
        const default_point_color = 'rgba(255, 200, 0, 0.5)';
        const merging_point_color = 'rgba(255, 0, 0, 0.5)';

        function addPoint(x, y) {
          pos.push(new fabric.Point(x, y));
          fixed.push(false);
          anchored.push(false);
          const dot = new fabric.Circle({
            type: 'dot',
            index: nPoints++,
            left: x,
            top: y,
            radius: pointRadius,
            fill: default_point_color,
            stroke: '#666',
            strokeWidth: 3,
            objectCaching: false,
            selectable: true,
            hasControls: false,
            visible: true,
            renderOnAddRemove: false,
          });
          renderDots.push(dot);
          canvas.add(dot);
          dot.bringToFront();
          return dot.index;
        }

        function addEdge(i, j) {
          // make sure i < j
          if (i == j) console.error(`no self loop`);
          if (i > j) {
            const t = i;
            i = j;
            j = t;
          }

          if (i >= nPoints || j >= nPoints) console.error(`out of range`);
          const dist = pos[i].distanceFrom(pos[j]);
          edges.push({
            from: i,
            to: j,
            dist: dist,
          });
          const e = new fabric.Line([pos[i].x, pos[i].y, pos[j].x, pos[j].y], {
            type: 'line',
            index: nEdges++,
            stroke: 'rgba(255,0,0,0.3)',
            strokeWidth: 1,
            objectCaching: false,
            selectable: false,
            hasControls: false,
          });
          renderEdges.push(e);
          canvas.add(e);
          canvas.sendToBack(e);
        }

        function mergePoints(i, j) {
          if (i === j) return;
          if (i > j) {
            const t = i;
            i = j;
            j = t;
          }
          // we don't clean pos array, otherwise have to shift array
          // remove j's renderDot on canvas, renderDots array is not cleaned
          canvas.remove(renderDots[j]);

          // update edge list
          let edgeUpdated = false;
          for (let k = 0; k < edges.length; k++) {
            const e = edges[k];
            if (e.from === j) {
              e.from = i;
              // e.dist = pos[i].distanceFrom(pos[e.to]); // merge should not change rest length
              edgeUpdated = true;
            }
            if (e.to === j) {
              e.to = i;
              // e.dist = pos[i].distanceFrom(pos[e.from]);
              edgeUpdated = true;
            }
          }
          // update renderable lines
          if (edgeUpdated) {
            for (const line of renderEdges) {
              const e = edges[line.index];
              line.set({ x1: pos[e.from].x, y1: pos[e.from].y, x2: pos[e.to].x, y2: pos[e.to].y });
            }
          }

          // update renderable images
          if (edgeUpdated) {
            for (const img of renderImages) {
              for (let k = 0; k < img.chainIndices.length; k++) {
                if (img.chainIndices[k] === j) {
                  img.chainIndices[k] = i;
                }
              }
            }
          }
          canvas.renderAll();
        }

        // test add point
        // addPoint(100, 20);
        // addPoint(200, 20);
        // addPoint(300, 20);
        // addPoint(400, 20);

        // addEdge(0, 1);
        // addEdge(1, 2);
        // addEdge(2, 3);

        // addPoint(50, 20);
        // addPoint(50, 50);
        // addPoint(50, 90);
        // addEdge(4, 5);
        // addEdge(6, 5);

        // const i0 = addPoint(100, 80);
        // const i1 = addPoint(200, 80);
        // const i2 = addPoint(300, 80);
        // const i3 = addPoint(400, 80);

        // addEdge(i0, i1);
        // addEdge(i1, i2);
        // addEdge(i2, i3);

        canvas.on({
          'mouse:down': function (e) {
            if (!e.target) return;
            const obj = e.target;
            if (obj.type && obj.type === 'dot') {
              obj.opacity = 0.5;
              fixed[obj.index] = true;
              console.log(`point ${obj.index} selected!`);
              canvas.renderAll();
            } else if (obj.type && obj.type === 'image') {
              for (const idx of obj.chainIndices) {
                fixed[idx] = true;
              }
            }
          },
          'mouse:up': function (e) {
            if (!e.target) return;
            const obj = e.target;
            if (obj.type && obj.type === 'dot') {
              obj.opacity = 1;
              fixed[obj.index] = false;
              console.log(`point ${obj.index} de-selected!`);

              if (toMergeIndex >= 0) {
                console.log(`merging points ${obj.index} and ${toMergeIndex}`);
                // do the merging
                const curIdx = obj.index;
                mergePoints(obj.index, toMergeIndex);

                // back to normal
                if (toMergeIndex < curIdx) {
                  const otherDot = renderDots[toMergeIndex];
                  otherDot.fill = default_point_color;
                }
                toMergeIndex = -1;
                // merge changed relative position, so need to solve
                solveAndUpdate();
              }

              // canvas.discardActiveObject();
              canvas.renderAll();
            } else if (obj.type && obj.type === 'image') {
              for (const idx of obj.chainIndices) {
                fixed[idx] = false;
              }
            }
          },
          'object:moving': function (e) {
            if (!e.target) return;
            const obj = e.target;
            if (obj.type && obj.type === 'dot') {
              fixed[obj.index] = true;
              obj.opacity = 0.5;

              // update this dragged pos as fixed
              pos[obj.index].x = obj.left;
              pos[obj.index].y = obj.top;

              // may ready to merge?
              for (const otherDot of renderDots) {
                if (anchored[otherDot.index]) continue;
                if (obj !== otherDot && obj.intersectsWithObject(otherDot)) {
                  // ready to merge
                  otherDot.fill = merging_point_color;
                  toMergeIndex = otherDot.index;
                  break;
                } else {
                  // normal fill
                  otherDot.fill = default_point_color;
                  toMergeIndex = -1;
                }
              }

              solveAndUpdate();
              canvas.renderAll();
            } else if (obj.type && obj.type === 'image') {
              const attachIndices = obj.chainIndices;
              const c0 = [(pos[attachIndices[0]].x + pos[attachIndices[2]].x) / 2, (pos[attachIndices[0]].y + pos[attachIndices[2]].y) / 2];
              const c1 = [obj.left, obj.top];
              const off = [c1[0] - c0[0], c1[1] - c0[1]];
              for (const idx of attachIndices) {
                pos[idx].x += off[0];
                pos[idx].y += off[1];
              }
              solveAndUpdate();
              canvas.renderAll();

            }
          },
          'object:moved': function (e) {
          },
        });

        function solve() {
          for (let i = 0; i < maxIterations; i++) {
            let totalChange = 0;
            for (const e of edges) {
              const change = solveEdge(e.from, e.to, e.dist);
              totalChange += change;
            }

            // converged
            if (totalChange < changeThreshold) return true;
          }
          console.log(`maxIteration ${maxIterations} has reached!`);
          return false;
        }

        function solveEdge(i, j, dist) {
          if (i >= nPoints || j >= nPoints) console.error(`out of range`);
          if (fixed[i] && fixed[j]) return 0;

          const p1 = pos[i], p2 = pos[j];
          // optmize: no need to sqrt!
          const d = p1.distanceFrom(p2);
          if (Math.abs(d - dist) < equalEps) return 0;

          const dx = (p1.x - p2.x) / d;
          const dy = (p1.y - p2.y) / d;

          if (!fixed[i] && !anchored[i]) {
            const s = fixed[j] ? 1.0 : 0.5;
            const cx = -s * (d - dist) * dx;
            const cy = -s * (d - dist) * dy;
            pos[i].x += cx;
            pos[i].y += cy;
          }

          if (!fixed[j] && !anchored[j]) {
            const s = fixed[i] ? 1.0 : 0.5;
            const cx = s * (d - dist) * dx;
            const cy = s * (d - dist) * dy;
            pos[j].x += cx;
            pos[j].y += cy;
          }

          return Math.abs(d - dist);
        }

        function solveAndUpdate() {
          // calc position dots position change
          solve();

          // update renderables (dots and lines)
          for (const dot of renderDots) {
            const idx = dot.index;
            dot.left = pos[idx].x;
            dot.top = pos[idx].y;
            dot.setCoords();
          }

          for (const line of renderEdges) {
            const idx = line.index;
            const p1 = pos[edges[idx].from];
            const p2 = pos[edges[idx].to];
            line.set({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y });
          }

          // update image assets
          for (const img of renderImages) {
            updateImagePosition(img);
            img.setCoords();
          }
        }

        function bake() {
          // update all constraint to be current value
          for (const edge of edges) {
            const p1 = pos[edge.from];
            const p2 = pos[edge.to];
            edge.dist = p1.distanceFrom(p2);
          }

          // update display
          solveAndUpdate();
        }

        function toogleHelper() {
          showHelper = !showHelper;

          // update all renderables
          for (const dot of renderDots) {
            dot.visible = showHelper;
          }
          for (const edge of renderEdges) {
            edge.visible = showHelper;
          }
          canvas.renderAll();
        }
        document.getElementById('showHelper').onclick = toogleHelper;

        function anchor() {
          console.log(`here!`);
          const obj = canvas.getActiveObject();
          if (obj && obj.type && obj.type === 'dot') {
            anchored[obj.index] = !anchored[obj.index];
            if (anchored[obj.index]) {
              obj.fill = 'rgba(0,0,255,1)'
            } else {
              obj.fill = default_point_color;
            }
          }
          canvas.renderAll();
        }
        document.getElementById('anchor').onclick = anchor;

        // we may use different sets of points to 'span' the object
        function attachPoints(obj) {
          const s = obj.scaleX ? obj.scaleX : 1;
          const halfW = obj.width / 2 * s;
          const halfH = obj.height / 2 * s;
          const cx = obj.left;
          const cy = obj.top;

          const top = addPoint(cx, cy - halfH);
          const right = addPoint(cx + halfW, cy);
          const bottom = addPoint(cx, cy + halfH);
          const left = addPoint(cx - halfW, cy);

          addEdge(top, right);
          addEdge(top, bottom);
          addEdge(top, left);
          addEdge(right, bottom);
          addEdge(bottom, left);
          addEdge(left, right);

          // mapping from asset to attached points need to be saved
          obj.chainIndices = [top, right, bottom, left];
        }

        function updateImagePosition(img) {
          if (!img.chainIndices) console.error(`no chaining points detected`);
          const [top, right, bottom, left] = img.chainIndices;

          // three points are necessary to compute full transform to new position
          // T = current(p1, p2, p3) * inverse(original (p1, p2, p3));
          // 2d case is easier, use two vector is sufficient to compute rotation
          const cx = [(pos[left].x + pos[right].x) / 2, (pos[left].y + pos[right].y) / 2];
          const s = img.scaleX ? img.scaleX : 1;
          const v1 = [0, -img.height / 2 * s]; // pointing up
          const v2 = [img.width / 2 * s, 0]; // pointing right
          const nv1 = [pos[top].x - cx[0], pos[top].y - cx[1]];
          const nv2 = [pos[right].x - cx[0], pos[right].y - cx[1]];
          const r0 = nv1[0] * v2[1] + nv2[0] * (-v1[1]);
          const r1 = nv1[1] * v2[1] + nv2[1] * (-v1[1]);
          const angle = Math.atan2(r1, r0);

          img.left = cx[0];
          img.top = cx[1];
          img.angle = angle * 180 / Math.PI;
        }

        function loadShape(file) {
          if (!file || file === '') return;
          fabric.Image.fromURL(file, function (img) {
            console.log(`load one shape ${img.width}X${img.height} onto canvas!`);
            lastFile = file;
            img.set({ left: canvas.getWidth() / 2, top: canvas.getHeight() / 2 });
            const dim = Math.max(img.width, img.height);
            const scale = dim < maxImageDimension ? 1.0 : maxImageDimension / dim;
            img.scale(scale);
            img.set('type', 'image');
            img.set('hasControls', false);
            img.set('objectCaching', false);
            img.set('selectable', true);
            canvas.add(img);
            // canvas.sendToBack(img);
            canvas.bringToFront();
            attachPoints(img);
            renderImages.push(img);
          });
        }

        function customLoad(e) {
          var fileType = e.target.files[0].type;
          var url = URL.createObjectURL(e.target.files[0]);
          if (fileType === 'image/png' || fileType === 'image/jpeg' || fileType === 'image/jpg') {
            loadShape(url);
          } else if (fileType === 'image/svg+xml') {
            // fabric.loadSVGFromURL(url, function(objects, options) {});
          }
        }

        document.getElementById('load-circle').onclick = (function () { loadShape('./lib/circle.png'); });
        document.getElementById('load-bar1').onclick = (function () { loadShape('./lib/5.png'); });
        document.getElementById('load-bar2').onclick = (function () { loadShape('./lib/0.png'); });
        document.getElementById('load-bar3').onclick = (function () { loadShape('./lib/2.png'); });
        document.getElementById('load-nuron1').onclick = (function () { loadShape('./lib/1.png'); });
        document.getElementById('load-nuron2').onclick = (function () { loadShape('./lib/3.png'); });
        document.getElementById('load-nuron-head').onclick = (function () { loadShape('./lib/nuron-head.png'); });
        document.getElementById('load-nuron-stem').onclick = (function () { loadShape('./lib/nuron-stem.png'); });
        document.getElementById('load-nuron-tail').onclick = (function () { loadShape('./lib/nuron-tail.png'); });
        document.getElementById('load-chemistry').onclick = (function () { loadShape('./lib/4.png'); });
        document.getElementById('load-cell').onclick = (function () { loadShape('./lib/6.png'); });
        document.getElementById('load-last').onclick = (function () { loadShape(lastFile); });
        document.getElementById('load-custom').addEventListener('change', customLoad, false);
        document.getElementById('shrink').onclick = (function () {
          for (const edge of edges) {
            edge.dist *= (1 - 0.01);
          }
          solveAndUpdate();
          canvas.renderAll();
        });
        document.getElementById('expand').onclick = (function () {
          for (const edge of edges) {
            edge.dist *= (1 + 0.01);
          }
          solveAndUpdate();
          canvas.renderAll();
        });

      })();
    </script>

  </div>


  <script>
    (function () {
      window.addEventListener('load', function () {
        var canvas = this.__canvas || this.canvas,
          canvases = this.__canvases || this.canvases;

        setSize();
        window.addEventListener('resize', setSize);

        function setSize() {
          var height = window.innerHeight - 100;
          var width = window.innerWidth - 50;
          canvas.setDimensions({ width: width, height: height });
          canvas.renderAll();
        };
        canvas && canvas.calcOffset && canvas.calcOffset();
        if (canvases && canvases.length) {
          for (var i = 0, len = canvases.length; i < len; i++) {
            canvases[i].calcOffset();
          }
        }
      });
    })();
  </script>


</body>

</html>