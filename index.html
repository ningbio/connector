<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Connector Test</title>
  <script src='./lib/fabric.min.js'></script>
</head>

<body>
  <div id="bd-wrapper" ng-controller="CanvasControls">
    <h2>Connector Test</h2>
    <p>
      Validate behaviors of connectors
    <p>
      <button id="anchor">load connections</button>
      <button id="showHelper">toggle ui</button>
      <!-- <button id="shrink">shrink</button>
      <button id="expand">expand</button>
      <button id="load-circle">circle</button>
      <button id="load-bar1">bar1</button>
      <button id="load-bar2">bar2</button>
      <button id="load-bar3">bar3</button>
      <button id="load-nuron1">neuron1</button>
      <button id="load-nuron2">neuron2</button>
      <button id="load-nuron-head">neuron-head</button>
      <button id="load-nuron-stem">neuron-stem</button>
      <button id="load-nuron-tail">neuron-tail</button>
      <button id="load-chemistry">chemistry</button> -->
      <!-- <button id="load-cell">cell</button> -->
      <button id="load-last">load last</button>
      <input type="file" id="load-custom"></input>
    </p>

    <canvas id="c" width="1200" height="650" style="border:1px solid #ccc"></canvas>
    <script id="main">(function () {
        var canvas = this.__canvas = new fabric.Canvas('c');
        canvas.setWidth(window.width);
        canvas.setHeight(window.height);
        fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';
        fabric.Object.prototype.transparentCorners = false;
        fabric.Object.prototype.objectCaching = true;
        canvas.selection = false; // no group selection
        canvas.on('object:modified', function (e) {
          console.log("Object modified");
          if (e.target.type === 'image') {
            // show the default attaching points
            updateDefautAnchors(e.target);
            updateConnectors(e.target);
            solveAndUpdate();
            canvas.renderAll();
          }
        });

        canvas.on('object:rotating', function (e) {
          if (e.target.type === 'image') {
            updateDefautAnchors(e.target);
            updateConnectors(e.target);
            solveAndUpdate();
            canvas.renderAll();
          }
        });

        // positions, fixed, edge array
        let nPoints = 0;
        let nConn = 0;
        let pos = [];
        let fixed = [];
        let anchored = [];
        let edges = [];
        let nIcons = 0;
        // let connectors = [];

        // visual elements
        let renderDots = [];
        let renderEdges = [];
        let renderImages = [];
        let renderConnectors = [];

        let toMergeIndex = -1;
        let showHelper = true;
        let lastFile = '';

        const pointRadius = 5;
        const maxImageDimension = 300; // pix
        const default_point_color = 'rgba(255, 200, 0, 0.5)';
        const merging_point_color = 'rgba(255, 0, 0, 0.5)';
        const PathType = { "Line": 0, "Elbow": 1, "Curve": 2 };

        loadShape('./lib/rect.png', 300, 200, nIcons++);

        loadShape('./lib/rect.png', 200, 400, nIcons++);
        loadShape('./lib/rect.png', 400, 400, nIcons++);
        loadShape('./lib/rect.png', 600, 400, nIcons++);

        loadShape('./lib/rect1.png', 600, 50, nIcons++);
        loadShape('./lib/rect.png', 600, 150, nIcons++);


        loadShape('./lib/rect.png', 700, 500, nIcons++);
        loadShape('./lib/rect.png', 700, 600, nIcons++);

        // update lines connected to this shape
        function updateConnectors(obj) {
          for (let i = 0; i < renderConnectors.length; i++) {
            const con = renderConnectors[i];
            const index = con.index;
            const objA = con.objA;
            const objB = con.objB;
            if (objA === obj || objB === obj) {
              const points = getPathPoints(objA, con.anchorA, objB, con.anchorB);
              const svgStr = getPathString(con.pathType, points);
              const newPath = new fabric.Path(svgStr);
              con.path = newPath.path;
            }
          }
        }

        function getPathString(type, points) {
          if (type === PathType.Curve) {
            if (points.length !== 4) {
              console.error('non-cubic bezier curve!');
            }

            let str = "M" + points[0][0] + ',' + points[0][1];
            str += "C" + points[1][0] + ',' + points[1][1] + ',';
            str += points[2][0] + ',' + points[2][1] + ',';
            str += points[3][0] + ',' + points[3][1];
            return str;
          } else { // polyline
            if (points.length < 2) {
              console.error('size of points < 2!');
            }
            let str = "M" + points[0][0] + ',' + points[0][1] + ',';
            for (let i = 1; i < points.length; i++) {
              str += points[i][0] + ',' + points[i][1];
              if (i !== points.length - 1) {
                str += ',';
              }
            }
            return str;
          }
        }

        // get the anchor position and tangent based on [u,v]
        function getAnchorInfo(obj, uv, pathType = PathType.Curve) {
          const [cx, cy] = [obj.left, obj.top];
          const u = uv[0], v = uv[1];
          if (!uv) {
            return [[cx, cy], [0.5, 0]];
          }

          const sx = obj.scaleX ? obj.scaleX : 1;
          const sy = obj.scaleY ? obj.scaleY : 1;
          const W = obj.width * sx;
          const H = obj.height * sy;
          const halfW = W / 2;
          const halfH = H / 2;
          const angle = obj.angle; // 0~360
          const cosV = Math.cos(angle / 180 * Math.PI);
          const sinV = Math.sin(angle / 180 * Math.PI);
          const vecs = [[0, -1], [1, 0], [0, 1], [-1, 0]]; // top, right, bottom, left

          if (v === 0) {
            // attach top edge
            const vec = vecs[0];
            const nx = cosV * vec[0] - sinV * vec[1];
            const ny = sinV * vec[0] + cosV * vec[1];
            const len = halfH;
            const pos = [cx + len * nx + (u - 0.5) * W * (-ny), cy + len * ny + (u - 0.5) * W * nx];
            return [pos, [nx, ny]];
          } else if (v === 1) {
            // attach bottom edge
            const vec = vecs[2];
            const nx = cosV * vec[0] - sinV * vec[1];
            const ny = sinV * vec[0] + cosV * vec[1];
            const len = halfH;
            const pos = [cx + len * nx + (u - 0.5) * W * (ny), cy + len * ny + (u - 0.5) * W * (-nx)];
            return [pos, [nx, ny]];
          } else if (u === 0) {
            // attach left edge
            const vec = vecs[3];
            const nx = cosV * vec[0] - sinV * vec[1];
            const ny = sinV * vec[0] + cosV * vec[1];
            const len = halfW;
            const pos = [cx + len * nx + (v - 0.5) * H * (ny), cy + len * ny + (v - 0.5) * H * (-nx)];
            return [pos, [nx, ny]];
          } else if (u === 1) {
            // attach right edge
            const vec = vecs[1];
            const nx = cosV * vec[0] - sinV * vec[1];
            const ny = sinV * vec[0] + cosV * vec[1];
            const len = halfW;
            const pos = [cx + len * nx + (v - 0.5) * H * (-ny), cy + len * ny + (v - 0.5) * H * nx];
            return [pos, [nx, ny]];
          } else {
            // attach inner anchor
            const vec = [u - 0.5, v - 0.5];
            const nx = cosV * vec[0] - sinV * vec[1];
            const ny = sinV * vec[0] + cosV * vec[1];
            const pos = [cx + halfW * nx + (u - 0.5) * W * (-ny), cy + halfH * ny + (v - 0.5) * H * nx];
            return [pos, [nx, ny]];
          }
        }

        function getPathPoints(objA, anchorA, objB, anchorB, pathType) {

          const start = [objA.left, objA.top];
          const end = [objB.left, objB.top];

          // compute anchor positions based on [u,v]
          if (pathType === PathType.Line) {
            return [start, end];
          } else if (pathType === PathType.Elbow) {
            return [start, [(objA.left + objB.left) / 2, objA.top], [(objA.left + objB.left) / 2, objB.top], end];
          } else { // curve
            // here tangent is always available and normalized(because we only rotate unit vectors), it is required by curves
            const [posA, tA] = getAnchorInfo(objA, anchorA);
            const [posB, tB] = getAnchorInfo(objB, anchorB);

            const spanA = Math.abs((posA[0] - posB[0]) * tA[0] + (posA[1] - posB[1]) * tA[1]) / 2;
            const spanB = Math.abs((posA[0] - posB[0]) * tB[0] + (posA[1] - posB[1]) * tB[1]) / 2;

            const TPA = [posA[0] + tA[0] * spanA, posA[1] + tA[1] * spanA];
            const TPB = [posB[0] + tB[0] * spanB, posB[1] + tB[1] * spanB];

            return [posA, TPA, TPB, posB];
          }

        }

        function connect(objA, anchorA, objB, anchorB, pathType = PathType.Elbow) {
          // fetch path data from A, B layout
          const points = getPathPoints(objA, anchorA, objB, anchorB, pathType);
          // const points = [[50, 50], [100, 50], [100, 100], [150, 100]];
          const svgStr = getPathString(pathType, points);

          // renderConnector          
          const idx = nConn++;
          const renderLine = new fabric.Path(svgStr, {
            type: 'connector',
            pathType: pathType,
            index: idx,
            fill: '',
            stroke: 'black',
            objectCaching: false,
            selectable: false,
            objA,
            anchorA,
            objB,
            anchorB,
            offset: 0,
          });
          renderConnectors.push(renderLine);
          canvas.add(renderLine);
          renderLine.sendToBack();

          // bookkeeping in objects being connected
          objA.connectors.push(renderLine);
          objB.connectors.push(renderLine);
        }

        function addPoint(x, y, dragable = false) {
          pos.push(new fabric.Point(x, y));
          fixed.push(false);
          anchored.push(false);
          const dot = new fabric.Circle({
            type: 'dot',
            index: nPoints++,
            left: x,
            top: y,
            radius: pointRadius,
            fill: default_point_color,
            stroke: '#666',
            strokeWidth: 3,
            objectCaching: false,
            selectable: dragable,
            hasControls: false,
            visible: true,
            renderOnAddRemove: false,
          });
          renderDots.push(dot);
          canvas.add(dot);
          dot.bringToFront();
          return dot.index;
        }

        let isDraggingAnchor = false;
        canvas.on({
          'mouse:down': function (e) {
            if (!e.target) return;
            const obj = e.target;
            if (obj.type && obj.type === 'dot') {
              // obj.opacity = 0.5;
              // fixed[obj.index] = true;
              console.log(`point ${obj.index} selected!`);
              canvas.renderAll();
            } else if (obj.type && obj.type === 'image') {
              // for (const idx of obj.chainIndices) {
              //   fixed[idx] = true;
              // }
            }
          },
          'mouse:up': function (e) {
            if (!e.target) return;
            const obj = e.target;
            if (obj.type && obj.type === 'dot') {
              // obj.opacity = 1;
              // fixed[obj.index] = false;
              console.log(`point ${obj.index} de-selected!`);

              if (toMergeIndex >= 0) {
                // console.log(`merging points ${obj.index} and ${toMergeIndex}`);
                // // do the merging
                const curIdx = obj.index;
                // mergePoints(obj.index, toMergeIndex);

                // back to normal
                if (toMergeIndex < curIdx) {
                  const otherDot = renderDots[toMergeIndex];
                  otherDot.fill = default_point_color;
                }
                toMergeIndex = -1;
                // merge changed relative position, so need to solve
                // solveAndUpdate();
              }

              // canvas.discardActiveObject();
              canvas.renderAll();
            } else if (obj.type && obj.type === 'image') {
              for (const idx of obj.chainIndices) {
                // fixed[idx] = false;
              }
            }
          },
          'object:moving': function (e) {
            if (!e.target) return;
            const obj = e.target;
            if (obj.type && obj.type === 'dot') {

              console.log(`moving dot!`);
              // fixed[obj.index] = true;
              // obj.opacity = 0.5;

              // // update this dragged pos as fixed
              // pos[obj.index].x = obj.left;
              // pos[obj.index].y = obj.top;

              // // may ready to merge?
              // for (const otherDot of renderDots) {
              //   if (anchored[otherDot.index]) continue;
              //   if (obj !== otherDot && obj.intersectsWithObject(otherDot)) {
              //     // ready to merge
              //     otherDot.fill = merging_point_color;
              //     toMergeIndex = otherDot.index;
              //     break;
              //   } else {
              //     // normal fill
              //     otherDot.fill = default_point_color;
              //     toMergeIndex = -1;
              //   }
              // }

              // solveAndUpdate();
              // canvas.renderAll();
            } else if (obj.type && obj.type === 'image') {
              updateDefautAnchors(obj);
              updateConnectors(obj);

              // const attachIndices = obj.chainIndices;
              // const c0 = [(pos[attachIndices[0]].x + pos[attachIndices[2]].x) / 2, (pos[attachIndices[0]].y + pos[attachIndices[2]].y) / 2];
              // const c1 = [obj.left, obj.top];
              // const off = [c1[0] - c0[0], c1[1] - c0[1]];
              // for (const idx of attachIndices) {
              //   pos[idx].x += off[0];
              //   pos[idx].y += off[1];
              // }
              solveAndUpdate();
              canvas.renderAll();

            }
          },
          'object:moved': function (e) {
          },
        });

        function solveAndUpdate() {
          // calc position dots position change
          // solve();

          // update renderables (dots and lines)
          for (const dot of renderDots) {
            const idx = dot.index;
            dot.left = pos[idx].x;
            dot.top = pos[idx].y;
            dot.setCoords();
          }

          // for (const line of renderEdges) {
          //   const idx = line.index;
          //   const p1 = pos[edges[idx].from];
          //   const p2 = pos[edges[idx].to];
          //   line.set({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y });
          // }

          // update image assets
          // for (const img of renderImages) {
          //   updateImagePosition(img);
          //   img.setCoords();
          // }
        }

        function toogleHelper() {
          showHelper = !showHelper;

          // update all renderables
          for (const dot of renderDots) {
            dot.visible = showHelper;
          }
          for (const edge of renderEdges) {
            edge.visible = showHelper;
          }
          canvas.renderAll();
        }
        document.getElementById('showHelper').onclick = toogleHelper;

        function anchor() {
          // const obj = canvas.getActiveObject();
          //const connectors = canvas.getObjects().filter(obj => obj.type === 'image');
          connect(getIcon(0), [0.4, 1], getIcon(1), [0.5, 0], PathType.Curve);
          connect(getIcon(0), [0.5, 1], getIcon(2), [0.5, 0], PathType.Curve);
          connect(getIcon(0), [0.6, 1], getIcon(3), [0.5, 0], PathType.Curve);

          connect(getIcon(0), [1, 0.5], getIcon(4), [0, 0.5], PathType.Curve);
          connect(getIcon(0), [1, 0.5], getIcon(5), [0.25, 0.25], PathType.Curve);

          connect(getIcon(6), [1, 0.5], getIcon(7), [0.5, 0], PathType.Elbow);

          canvas.renderAll();
        }
        document.getElementById('anchor').onclick = anchor;

        // default anchor points
        function attachDefaultAnchors(obj) {
          const s = obj.scaleX ? obj.scaleX : 1;
          const halfW = obj.width / 2 * s;
          const halfH = obj.height / 2 * s;
          const cx = obj.left;
          const cy = obj.top;

          const top = addPoint(cx, cy - halfH);
          const right = addPoint(cx + halfW, cy);
          const bottom = addPoint(cx, cy + halfH);
          const left = addPoint(cx - halfW, cy);

          // mapping from asset to attached points need to be saved
          obj.chainIndices = [top, right, bottom, left];
        }

        // update visual default anchors
        function updateDefautAnchors(obj) {
          const sx = obj.scaleX ? obj.scaleX : 1;
          const sy = obj.scaleY ? obj.scaleY : 1;
          const halfW = obj.width / 2 * sx;
          const halfH = obj.height / 2 * sy;
          const cx = obj.left;
          const cy = obj.top;
          const angle = obj.angle; // 0~360
          const cosV = Math.cos(angle / 180 * Math.PI);
          const sinV = Math.sin(angle / 180 * Math.PI);

          const vecs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
          let newV = [];
          for (let i = 0; i < 4; i++) {
            const nx = cosV * vecs[i][0] - sinV * vecs[i][1];
            const ny = sinV * vecs[i][0] + cosV * vecs[i][1];
            newV.push({ x: nx, y: ny });
            const len = (i === 0 || i === 2) ? halfH : halfW;
            pos[obj.chainIndices[i]] = {
              x: cx + len * nx,
              y: cy + len * ny
            };
          }
        }

        function updateImagePosition(img) {
          if (!img.chainIndices) console.error(`no chaining points detected`);
          const [top, right, bottom, left] = img.chainIndices;

          // three points are necessary to compute full transform to new position
          // T = current(p1, p2, p3) * inverse(original (p1, p2, p3));
          // 2d case is easier, use two vector is sufficient to compute rotation
          const cx = [(pos[left].x + pos[right].x) / 2, (pos[left].y + pos[right].y) / 2];
          const s = img.scaleX ? img.scaleX : 1;
          const v1 = [0, -img.height / 2 * s]; // pointing up
          const v2 = [img.width / 2 * s, 0]; // pointing right
          const nv1 = [pos[top].x - cx[0], pos[top].y - cx[1]];
          const nv2 = [pos[right].x - cx[0], pos[right].y - cx[1]];
          const r0 = nv1[0] * v2[1] + nv2[0] * (-v1[1]);
          const r1 = nv1[1] * v2[1] + nv2[1] * (-v1[1]);
          const angle = Math.atan2(r1, r0);

          img.left = cx[0];
          img.top = cx[1];
          img.angle = angle * 180 / Math.PI;
        }

        function loadShape(file, x = 300, y = 300, iconId) {
          if (!file || file === '') return;
          fabric.Image.fromURL(file, function (img) {
            console.log(`load one shape ${img.width}X${img.height} onto canvas!`);
            lastFile = file;
            img.set({ left: canvas.getWidth() / 2 | x, top: canvas.getHeight() / 2 | y });
            const dim = Math.max(img.width, img.height);
            const scale = dim < maxImageDimension ? 1.0 : maxImageDimension / dim;
            img.scale(scale);
            img.set('type', 'image');
            img.set('hasControls', true);
            img.set('objectCaching', false);
            img.set('selectable', true);
            img.iconId = iconId;
            img.connectors = [];
            canvas.add(img);
            // canvas.sendToBack(img);
            canvas.bringToFront();
            attachDefaultAnchors(img);
            renderImages.push(img);
          });
        }

        function getIcon(iconId) {
          return canvas.getObjects().filter(obj => obj.type === 'image' && obj.iconId === iconId)[0];
        }

        function customLoad(e) {
          var fileType = e.target.files[0].type;
          var url = URL.createObjectURL(e.target.files[0]);
          if (fileType === 'image/png' || fileType === 'image/jpeg' || fileType === 'image/jpg') {
            loadShape(url, nIcons++);
          } else if (fileType === 'image/svg+xml') {
            // fabric.loadSVGFromURL(url, function(objects, options) {});
          }
        }

        // document.getElementById('load-circle').onclick = (function () { loadShape('./lib/circle.png'); });
        // document.getElementById('load-bar1').onclick = (function () { loadShape('./lib/5.png'); });
        // document.getElementById('load-bar2').onclick = (function () { loadShape('./lib/0.png'); });
        // document.getElementById('load-bar3').onclick = (function () { loadShape('./lib/2.png'); });
        // document.getElementById('load-nuron1').onclick = (function () { loadShape('./lib/1.png'); });
        // document.getElementById('load-nuron2').onclick = (function () { loadShape('./lib/3.png'); });
        // document.getElementById('load-nuron-head').onclick = (function () { loadShape('./lib/nuron-head.png'); });
        // document.getElementById('load-nuron-stem').onclick = (function () { loadShape('./lib/nuron-stem.png'); });
        // document.getElementById('load-nuron-tail').onclick = (function () { loadShape('./lib/nuron-tail.png'); });
        // document.getElementById('load-chemistry').onclick = (function () { loadShape('./lib/4.png'); });
        // document.getElementById('load-cell').onclick = (function () { loadShape('./lib/6.png'); });
        document.getElementById('load-last').onclick = (function () { loadShape(lastFile, nIcons++); });
        document.getElementById('load-custom').addEventListener('change', customLoad, false);
      })();
    </script>

  </div>


  <script>
    (function () {
      window.addEventListener('load', function () {
        var canvas = this.__canvas || this.canvas,
          canvases = this.__canvases || this.canvases;

        setSize();
        window.addEventListener('resize', setSize);

        function setSize() {
          var height = window.innerHeight - 100;
          var width = window.innerWidth - 50;
          canvas.setDimensions({ width: width, height: height });
          canvas.renderAll();
        };
        canvas && canvas.calcOffset && canvas.calcOffset();
        if (canvases && canvases.length) {
          for (var i = 0, len = canvases.length; i < len; i++) {
            canvases[i].calcOffset();
          }
        }
      });
    })();
  </script>


</body>

</html>